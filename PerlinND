using System;
//C#
//Benjamin Coupry

namespace PerlinNDim
{
    class Program
    {
        public enum TypeInterpolation { Lineaire, Cosinus, Hermite, C2 };
        
        //Exemple en 2D
        static void Main(string[] args)
        {
            using (System.IO.StreamWriter file =
            new System.IO.StreamWriter(@"D:/XXX.csv"))
            {
                for (int i = 0; i < 220; i++)
                {
                    if(i%10 ==0)
                    Console.WriteLine(i);
                    file.WriteLine();
                    double x = (double)i / 100.0;
                    for (int j = 0; j < 220; j++)
                    {
                        double y = (double)j / 100.0;
                        double r = perlin(new double[] { x, y }, 10, TypeInterpolation.C2, 5, 1, 0.5, 2);
                        file.Write(r + ";");
                    }
                }
            }
        }
        
        //Fonctions pseudoAlea
        private static double pseudo_Alea(int N, int seed)
        {
            //Retourne un double pseudo aleatoire N->R, (de developpez.com)
            N = N + seed*58900;
            N = (N << 13) ^ N;
            N = (N * (N * N * 15731 + 789221)) + 1376312589;
            return 1.0 - (N & 0x7fffffff) / 1073741824.0;
        }
        private static double pseudo_Alea_Rn(int[] V, int seed)
        {
            //Retourne un double pseudo aleatoire N^k->R
            int Taille = V.Length;
            double tmp = 0.0;
            for (int i = 0; i < Taille; i++)
            {
                tmp = (tmp * 850000.0);
                tmp = pseudo_Alea((int)tmp + V[i], seed);
            }
            return tmp;
        }
        private static double[] vect_pseudo_Alea_Rn(int[] V, int seed)
        {
            //Renvoie un vecteur de l'hypershere de dimention n, n etant la dimention de v
            int Taille = V.Length;
            double[] Retour = new double[Taille];
            double Norme;
            do
            {
                //Generer un vecteur dans l'hypercube
                for (int i = 0; i < Taille; i++)
                {
                    Retour[i] = pseudo_Alea_Rn(V, seed);
                    seed += 1;
                }
                Norme = normeVect(Retour);
            }
            while (Norme == 0 || Norme > 1.0);
            //Le vecteur est dans l'hyperboule, le normaliser
            multiplierVect(ref Retour, 1.0 / Norme);
            return Retour;
        }
        private static double[] vect_pseudo_Alea(int N,int Taille, int seed)
        {
            //Renvoie un vecteur de l'hypershere de dimention Taille
            double[] Retour = new double[Taille];
            double Norme;
            do
            {
                //Generer un vecteur dans l'hypercube
                for (int i = 0; i < Taille; i++)
                {
                    Retour[i] = pseudo_Alea(N, seed);
                    seed += 1;
                }
                Norme = normeVect(Retour);
            }
            while (Norme == 0 || Norme > 1.0);
            //Le vecteur est dans l'hyperboule, le normaliser
            multiplierVect(ref Retour, 1.0 / Norme);
            return Retour;
        }

        //Interpolation
        private static double fonctionsInterp(double x, TypeInterpolation Interp)
        {
            //Renvoie le coefficient d'interpolation k [0,1] en fonction du parcours x
            double result;
            switch (Interp)
            {
                case TypeInterpolation.Lineaire:
                    result = x;
                    break;
                case TypeInterpolation.Cosinus:
                    result = 0.5 * (1.0 - Math.Cos(x));
                    break;
                case TypeInterpolation.Hermite:
                    result = 3.0 * x * x - 2.0 * x * x * x;
                    break;
                case TypeInterpolation.C2:
                    result = 6.0 * x * x * x * x * x - 15.0 * x * x * x * x + 10.0 * x * x * x;
                    break;
                default:
                    result = 0.0;
                    break;
            }
            return result;
        }
        private static double interpolerEspace(double[] Position, int[] PosGrille, int N0, int seed, TypeInterpolation TI)
        {
            //Permet d'obtenir une interpolation pour une sous dim, a partir d'une selection des coordonees du point de ref pour les dim superieures
            if (N0 < 0)
            {
                //La valeur voulue pour un point de la grille est le produit scalaire entre le gradient a la position de la grille voulue, et la distance a cette position
                double[] dist = recentrer(PosGrille, Position);
                return produitScalaire(dist, vect_pseudo_Alea_Rn(PosGrille, seed));
            }
            else
            {
                //On choisit la dim N0 (2 choix) et on interpole les deux options entre elles
                double x = Position[N0];
                //projection sur la dim N0 et recuperation du coeff d'interpolation
                double k = fonctionsInterp(x - Math.Floor(x), TI);
                int[] P1 = copie(PosGrille);
                int[] P2 = copie(PosGrille);
                //fixer la valeur pour la dim N0
                P1[N0] = (int)Math.Floor(Position[N0]);
                P2[N0] = (int)Math.Floor(Position[N0]) + 1;
                //interpolation
                double b1 = interpolerEspace(Position, P1, N0 - 1, seed, TI);
                double b2 = interpolerEspace(Position, P2, N0 - 1, seed, TI);
                double inter = ((1.0 - k) * b1 + k * b2);
                return inter;
            }
        }
        private static double perlinSimple(ref double[] Position, int seed, TypeInterpolation TI)
        {
            //Obtient un bruit de perlin itere une fois et de frequence 1
            return Math.Min(Math.Max(interpolerEspace(Position, new int[Position.Length], Position.Length-1, seed, TI),-1.0),1.0);
        }
        
        //A APPELER
        public static double perlin(double[] Position, int seed, TypeInterpolation TI,int nbOctaves,double f0, double Attenuation,double Decalage)
        {
            //Renvoie un bruit de perlin a n dim pour l'interpolation specifiee
            double Resultat = 0.0;
            double Amplitude = 1.0;
            double f = f0;
            double[] shift = new double[Position.Length];
            double[] Pos = new double[Position.Length];
            for (int i=0;i<nbOctaves;i++)
            {
                shift = vect_pseudo_Alea(i*452237+700849,Position.Length,seed);
                multiplierVect(ref shift, Decalage * pseudo_Alea(i*89746+6577,seed));
                Pos = Position;
                shifter(ref Pos, ref shift);
                multiplierVect(ref Pos, f);
                Resultat += perlinSimple(ref Pos, seed, TI)*Amplitude;
                Amplitude *= Attenuation;
                f *= 2;
            }
            return Resultat;
        }
        
        //Fonctions vectorielles
        private static double produitScalaire(double[] V1, double[] V2)
        {
            //Produit scalaire de deux vecteurs
            int Taille = Math.Min(V1.Length, V2.Length);
            double Somme = 0.0;
            for (int i = 0; i < Taille; i++)
            {
                Somme += V1[i] * V2[i];
            }
            return Somme;
        }
        private static double normeVect(double[] V)
        {
            //Norme du vecteur v
            return Math.Sqrt(produitScalaire(V, V));
        }
        private static void multiplierVect(ref double[] V, double k)
        {
            //Multiplier le vecteur par k
            int Taille = V.Length;
            for (int i = 0; i < Taille; i++)
            {
                V[i] *= k;
            }
        }
        private static void shifter(ref double[] V1, ref double[] V2)
        {
            //renvoie le vecteur V1 = V1 +V2
            int Taille = Math.Min(V1.Length, V2.Length);
            for (int i = 0; i < Taille; i++)
            {
                V1[i] += V2[i];
            }
        }
        private static double[] recentrer(int[] V1, double[] V2)
        {
            //renvoie le vecteur V2-V1
            int Taille = Math.Min(V1.Length, V2.Length);
            double[] Resultat = new double[Taille];
            for (int i = 0; i < Taille; i++)
            {
                Resultat[i] = V2[i]-(double)V1[i];
            }
            return Resultat;
        }
        private static int[] copie(int[] V1)
        {
            //renvoie une copie de V1
            int Taille = V1.Length;
            int[] Resultat = new int[Taille];
            for (int i = 0; i < Taille; i++)
            {
                Resultat[i] = V1[i];
            }
            return Resultat;
        }
    }
}
